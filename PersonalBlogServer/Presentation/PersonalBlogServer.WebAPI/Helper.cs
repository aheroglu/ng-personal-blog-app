using Microsoft.AspNetCore.Identity;
using PersonalBlogServer.Domain.Entities;
using PersonalBlogServer.Persistence.Contexts;

namespace PersonalBlogServer.WebAPI;

public static class Helper
{
    public static async Task CreateDummyData(WebApplication app)
    {
        using (var scope = app.Services.CreateScope())
        {
            var context = scope.ServiceProvider.GetRequiredService<AppDbContext>();
            var userManager = scope.ServiceProvider.GetRequiredService<UserManager<AppUser>>();

            if (!userManager.Users.Any())
            {
                await userManager.CreateAsync(new()
                {
                    UserName = "ahmet34"
                }, "Ahmet2003!");
            }

            About about = new()
            {
                Content = "<h2><strong>Lorem ipsum dolor, sit amet consectetur adipisicing elitas. Quos, veritatis.</strong></h2><p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Architecto ipsum nesciunt debitis ullam? Iure, tempora vero ad nobis perspiciatis iste dolor reprehenderit officia alias. Asperiores, explicabo voluptatibus est alias perferendis dolorum vel, reiciendis aliquid non facilis quos similique beatae quibusdam qui. Laudantium aliquid consequatur perferendis quidem repudiandae fuga dignissimos explicabo.</p><p><i>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Architecto ipsum nesciunt debitis ullam? Iure, tempora vero ad nobis perspiciatis iste dolor reprehenderit officia alias. Asperiores, explicabo voluptatibus est alias perferendis dolorum vel, reiciendis aliquid non facilis quos similique beatae quibusdam qui. Laudantium aliquid consequatur perferendis quidem repudiandae fuga dignissimos explicabo.</i></p>",
                CreatedAt = DateTime.Now,
                UpdatedAt = DateTime.Now
            };

            IList<Message> messages = new List<Message>()
            {
                new()
                {
                    Name = "Alice Johnson",
                    Email = "alice.johnson@example.com",
                    Content = "Hello, I am sending you a message.",
                    CreatedAt= DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Name = "Bob Smith",
                    Email = "bob.smith@example.com",
                    Content = "Hello, I need your urgent assistance.",
                    CreatedAt= DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Name = "Emily Brown",
                    Email = "emily.brown@example.com",
                    Content = "Hello, can I get detailed information about your product",
                    CreatedAt= DateTime.Now,
                    UpdatedAt = DateTime.Now
                }
            };

            IList<Post> posts = new List<Post>()
            {
                new()
                {
                    Title = "Building Mobile Apps with Angular and Ionic",
                    Image = "c8e57679-5307-4147-bea7-a8b23cd9ebf6.jpg",
                    PostUrl = "building-mobile-apps-with-angular-and-ionic",
                    Description = "How To Create Your Mobile Apps Using Angular",
                    Content  = "<h2 style=\"margin-left:0px;\"><strong>Introduction</strong></h2><p style=\"margin-left:0px;\">Developing mobile applications has evolved significantly over the years. Today, you don’t have to be an expert in Java or Objective-C to build high-performance mobile apps for Android or iOS. In this article, I’ll walk you through a journey of building a mobile app using Angular and Ionic, two popular technologies for modern mobile app development.</p><h2 style=\"margin-left:0px;\"><strong>What are Angular and Ionic?</strong></h2><p style=\"margin-left:0px;\">Angular is a platform for building web applications. Developed by Google, Angular is an open-source front-end framework that empowers developers to create dynamic, single-page applications using HTML and TypeScript.</p><p style=\"margin-left:0px;\">Ionic, on the other hand, is a popular open-source framework for building cross-platform mobile apps using familiar web technologies such as HTML, CSS, and JavaScript. It leverages Angular for building the application logic, while providing a library of pre-designed components, gestures, and tools for developing fast, highly interactive apps.</p><p style=\"margin-left:0px;\">Together, Angular and Ionic form a potent combination, allowing developers to use their web development skills to build high-performance mobile apps that can run on multiple platforms.</p><h2 style=\"margin-left:0px;\"><strong>Setting Up the Environment</strong></h2><p style=\"margin-left:0px;\">Before we start developing our mobile app, we need to set up our development environment. We’ll need Node.js and npm (Node package manager) installed on our system. These are necessary to manage our project’s dependencies. You can download Node.js and npm from <a href=\"https://nodejs.org/en/download/\">here</a>.</p><p style=\"margin-left:0px;\">Once Node.js and npm are set up, install the Ionic CLI (Command Line Interface) and Angular CLI globally on your machine with the following commands:</p><p>npm install -g @ionic/cli<br>npm install -g @angular/cli</p><h2 style=\"margin-left:0px;\"><strong>Creating a New Ionic and Angular Project</strong></h2><p style=\"margin-left:0px;\">After setting up our environment, let’s create a new Ionic project with Angular. You can create a new project using the following command:</p><p>ionic start myApp tabs --type=angular</p><p style=\"margin-left:0px;\">This command creates a new Ionic app named “myApp” with a “tabs” template. The “ — type=angular” flag indicates that we want to use Angular for our project.</p><h2 style=\"margin-left:0px;\"><strong>Understanding the Project Structure</strong></h2><p style=\"margin-left:0px;\">Upon creating a new project, Ionic generates a standard project structure with various files and folders. The main folders include:</p><ul><li><strong>src:</strong> This is where you’ll spend most of your development time. It contains the app’s source code, including Angular components, templates, styles, and images.</li><li><strong>node_modules:</strong> This folder contains all the npm packages necessary for your project.</li><li><strong>www:</strong> This folder contains the built version of your application.</li></ul><p style=\"margin-left:0px;\">Let’s take a deeper look at the src folder. It contains several important sub-folders:</p><ul><li><strong>app:</strong> This folder contains all the Angular components, modules, and services for your app. Each component consists of a TypeScript file (.ts), a template file (.html), and a style file (.scss).</li><li><strong>assets:</strong> This folder is for storing images, icons, and other static files.</li><li><strong>environments:</strong> This folder is for setting different environment variables, like API endpoints.</li></ul><h2 style=\"margin-left:0px;\"><strong>Building a Simple App</strong></h2><p style=\"margin-left:0px;\">Let’s get our hands dirty by creating a simple app to display a list of items. First, let’s create a new Angular service to handle data. Run this command in the terminal:</p><p>ng generate service data</p><p style=\"margin-left:0px;\">This will create a new service file, data.service.ts, in the src/app folder. Let's add a method to this service to return a list of items:</p><p>import { Injectable } from '@angular/core';<br><br>@Injectable({<br>&nbsp; providedIn: 'root'<br>})<br>export class DataService {<br><br>&nbsp; private items: Array&lt;string&gt; = ['Item 1', 'Item 2', 'Item 3'];<br><br>&nbsp; constructor() { }<br><br>&nbsp; getItems() {<br>&nbsp; &nbsp; return this.items;<br>&nbsp; }<br>}</p><p style=\"margin-left:0px;\">Now, let’s create a new page to display this list of items. Run this command:</p><p>ionic generate page item-list</p><p style=\"margin-left:0px;\">This will create a new folder named item-list containing the necessary files for our new page. In the item-list.page.ts file, let's use our DataService to fetch the items:</p><p>import { Component, OnInit } from '@angular/core';<br>import { DataService } from '../data.service';<br><br>@Component({<br>&nbsp; selector: 'app-item-list',<br>&nbsp; templateUrl: './item-list.page.html',<br>&nbsp; styleUrls: ['./item-list.page.scss'],<br>})<br>export class ItemListPage implements OnInit {<br><br>&nbsp; items: Array&lt;string&gt;;<br><br>&nbsp; constructor(private dataService: DataService) { }<br><br>&nbsp; ngOnInit() {<br>&nbsp; &nbsp; this.items = this.dataService.getItems();<br>&nbsp; }<br><br>}</p><p style=\"margin-left:0px;\">And in item-list.page.html, let's display these items using Ionic components:</p><p>&lt;ion-header&gt;<br>&nbsp; &lt;ion-toolbar&gt;<br>&nbsp; &nbsp; &lt;ion-title&gt;Item List&lt;/ion-title&gt;<br>&nbsp; &lt;/ion-toolbar&gt;<br>&lt;/ion-header&gt;<br><br>&lt;ion-content&gt;<br>&nbsp; &lt;ion-list&gt;<br>&nbsp; &nbsp; &lt;ion-item *ngFor=\"let item of items\"&gt;<br>&nbsp; &nbsp; &nbsp; {{ item }}<br>&nbsp; &nbsp; &lt;/ion-item&gt;<br>&nbsp; &lt;/ion-list&gt;<br>&lt;/ion-content&gt;</p><h2 style=\"margin-left:0px;\"><strong>Running the App</strong></h2><p style=\"margin-left:0px;\">Finally, let’s run our app! Use the following command to serve your app:</p><p>ionic serve</p><p style=\"margin-left:0px;\">This will start a local development server, and you can view your app in your web browser. To run it on an emulator or real device, you can use:</p><p>ionic cordova run android # or ios</p><h2 style=\"margin-left:0px;\"><strong>Conclusion</strong></h2><p style=\"margin-left:0px;\">Building mobile apps with Angular and Ionic is an efficient way to leverage your web development skills for mobile platforms. We’ve just scratched the surface in this tutorial. There’s a lot more you can do, such as adding navigation, accessing native features, and styling your app with custom themes. Keep exploring and building amazing apps!</p><ol><li><a href=\"https://angular.io/docs\"><i>Angular Documentation</i></a></li><li><a href=\"https://ionicframework.com/docs\"><i>Ionic Framework Documentation</i></a></li></ol>",
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Title = "Build ASP.NET Core App with Angular",
                    Image = "61e768bb-7f2e-4772-afd4-c7eba551e444.png",
                    PostUrl = "build-asp.net-core-app-with-angular",
                    Description = "Let's Create Our Service Based Application",
                    Content = "<p style=\"margin-left:0px;\">Building an ASP.NET Core web application with Angular involves creating a backend API using ASP.NET Core and a front-end application using the Angular framework. Here are the steps to create a basic ASP.NET Core app with Angular:</p><p style=\"margin-left:0px;\">Prerequisites:</p><ol><li>Install Visual Studio or Visual Studio Code.</li><li>Install .NET SDK: https://dotnet.microsoft.com/download</li><li>Install Node.js and npm: https://nodejs.org/</li><li>Install Angular CLI: npm install -g @angular/cli</li></ol><p style=\"margin-left:0px;\">Step 1: Create the ASP.NET Core Web API Project</p><p style=\"margin-left:0px;\">Open your command prompt or terminal and navigate to the folder where you want to create your project.</p><ol><li>Create a new ASP.NET Core Web API project:</li></ol><ul><li>bashCopy code</li><li>dotnet new webapi -n MyAspNetCoreApp</li></ul><p style=\"margin-left:0px;\">2. Navigate to the project folder:</p><ul><li>bashCopy code</li><li>cd MyAspNetCoreApp</li></ul><p style=\"margin-left:0px;\">3. Open the project in Visual Studio or Visual Studio Code.</p><p style=\"margin-left:0px;\">Step 2 Create the Angular Front-end</p><ol><li>In the terminal, navigate to the project’s root folder.</li><li>Create a new Angular application using Angular CLI:</li></ol><ul><li>bashCopy code</li><li>ng new angular-app</li></ul><p style=\"margin-left:0px;\">3. Follow the prompts to configure your Angular app</p><p style=\"margin-left:0px;\">4. Once the Angular app is created, navigate to the Angular app folder:</p><ul><li>bashCopy code</li><li>cd angular-app</li></ul><p style=\"margin-left:0px;\">5. Open the src/environments/environment.ts file and configure the API URL to point to your ASP.NET Core API:</p><ul><li>typescript copy code</li><li>export const environment = { production: false, apiUrl: 'https://localhost:5001/api', // Replace with your API URL };</li></ul><p style=\"margin-left:0px;\">Step 3: Configure CORS in ASP.NET Core</p><p style=\"margin-left:0px;\">To allow cross-origin requests from the Angular app to the ASP.NET Core API, configure CORS in your Startup.cs file:</p><p>csharpCopy code// Startup.cspublic void ConfigureServices(IServiceCollection services)<br>{<br>&nbsp; &nbsp; // ...<br>&nbsp; &nbsp; services.AddCors(options =&gt;<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; options.AddPolicy(\"AllowAngularApp\",<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; builder =&gt; builder<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .WithOrigins(\"http://localhost:4200\") // Replace with your Angular app URL<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .AllowAnyHeader()<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .AllowAnyMethod()<br>&nbsp; &nbsp; &nbsp; &nbsp; );<br>&nbsp; &nbsp; });<br>&nbsp; &nbsp; // ...<br>}public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br>{<br>&nbsp; &nbsp; // ...<br>&nbsp; &nbsp; app.UseCors(\"AllowAngularApp\");<br>&nbsp; &nbsp; // ...<br>}</p><p style=\"margin-left:0px;\">Step 4: Create API Endpoints</p><p style=\"margin-left:0px;\">Create your API endpoints in the ASP.NET Core controller. For example:</p><p>csharpCopy code// Controllers/ValuesController.cs[ApiController]<br>[Route(\"api/[controller]\")]<br>public class ValuesController : ControllerBase<br>{<br>&nbsp; &nbsp; // GET api/values<br>&nbsp; &nbsp; [HttpGet]<br>&nbsp; &nbsp; public IActionResult Get()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; var values = new string[] { \"value1\", \"value2\" };<br>&nbsp; &nbsp; &nbsp; &nbsp; return Ok(values);<br>&nbsp; &nbsp; }<br>}</p><p style=\"margin-left:0px;\">Step 5: Connect Angular to ASP.NET Core API</p><p style=\"margin-left:0px;\">In your Angular components, you can use Angular’s HttpClient to make HTTP requests to the ASP.NET Core API. For example:</p><p>typescriptCopy codeimport { Injectable } from '@angular/core';<br>import { HttpClient } from '@angular/common/http';<br>import { environment } from 'src/environments/environment';@Injectable({<br>&nbsp; providedIn: 'root',<br>})<br>export class DataService {<br>&nbsp; constructor(private http: HttpClient) {} &nbsp;getValues() {<br>&nbsp; &nbsp; return this.http.get(`${environment.apiUrl}/values`);<br>&nbsp; }<br>}</p><p style=\"margin-left:0px;\">Now you can use them DataService to fetch data from your ASP.NET Core API in your Angular components.</p><p style=\"margin-left:0px;\">Step 6: Run the Application</p><ul><li>Run the ASP.NET Core application:</li><li>bashCopy code</li><li>dotnet run</li><li>Run the Angular application (from the Angular app folder):</li><li>bashCopy code</li><li>ng serve</li></ul><p style=\"margin-left:0px;\">Your ASP.NET Core app will run on, and your Angular app will run on http://localhost:4200. You can access the Angular app in your web browser and test the integration with the ASP.NET Core API.</p>",
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Title = "Clean Architecture",
                    Image = "6bfd675d-f676-48ea-aa95-d1d27edc779d.jpg",
                    PostUrl = "clean-architecture",
                    Description = "Clean Architecture: A Comprehensive Guide with C#",
                    Content = "<p style=\"margin-left:0px;\">Software developers face a constant challenge of creating scalable, maintainable, and flexible applications. As applications grow in complexity, it becomes crucial to adopt a design that keeps your codebase organized and easy to work with. Clean Architecture is an architectural approach that aims to solve this problem.</p><h2 style=\"margin-left:0px;\"><strong>1. What is Clean Architecture?</strong></h2><p style=\"margin-left:0px;\">A Clean Architecture is a software architectural approach introduced by Robert C. Martin, also known as Uncle Bob, that emphasizes separating concerns within an application for a maintainable, testable, and flexible codebase.</p><p style=\"margin-left:0px;\">Clean Architecture promotes the separation of concerns by dividing an application into distinct layers, each with a specific responsibility. These layers are designed to be independent of external concerns, such as the UI or database, and can be tested in isolation. The main idea is to maintain a clear boundary between the inner core of the application and the external dependencies.</p><h2 style=\"margin-left:0px;\"><strong>2. Clean Architecture Components</strong></h2><p style=\"margin-left:0px;\">Clean Architecture can be visually represented as a series of concentric circles, with the innermost circle being the core of the application. Each circle represents a different layer with specific responsibilities. Let’s break down these components:</p><p style=\"margin-left:0px;\"><strong>2.1 Entities</strong></p><p style=\"margin-left:0px;\">Entities represent the core business objects in your application. They are typically plain C# classes that encapsulate the essential data and behaviors of your domain. Entities are often persistent, meaning they have a unique identifier and can be saved in a database. In a C# application, entities can be implemented as classes or structures.</p><p style=\"margin-left:0px;\">Here’s an example of a simple entity in C#:</p><p>public class Product<br>{<br>&nbsp; &nbsp; public int Id { get; set; }<br>&nbsp; &nbsp; public string Name { get; set; }<br>&nbsp; &nbsp; public decimal Price { get; set; }<br>}</p><p style=\"margin-left:0px;\"><strong>3.2. Use Cases</strong></p><p style=\"margin-left:0px;\">Use Cases are the heart of your application’s business logic. They encapsulate the application’s core functionality and business rules. Use Cases do not depend on external components like the database or UI. Instead, they define the interactions between entities and implement the application’s specific behavior.</p><p style=\"margin-left:0px;\">In C#, Use Cases can be implemented as classes or methods. Here’s a simplified example of a Use Case for creating a new product:</p><p>public class CreateProductUseCase<br>{<br>&nbsp; &nbsp; private readonly IProductRepository _productRepository;<br><br>&nbsp; &nbsp; public CreateProductUseCase(IProductRepository productRepository)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; _productRepository = productRepository;<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; public void CreateNewProduct(Product product)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; // Business logic for creating a new product<br>&nbsp; &nbsp; &nbsp; &nbsp; if (product.Price &lt;= 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArgumentException(\"Product price must be greater than 0.\");<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br><br>&nbsp; &nbsp; &nbsp; &nbsp; _productRepository.Add(product);<br>&nbsp; &nbsp; }<br>}</p><p style=\"margin-left:0px;\"><strong>3.3. Interface Adapters</strong></p><p style=\"margin-left:0px;\">The Interface Adapters layer serves as a bridge between the inner core of the application and the external world, such as the user interface, databases, and web services. This layer contains components that adapt and communicate with external frameworks and tools. In C#, this may include controllers, presenters, and data access code.</p><p style=\"margin-left:0px;\">Here’s an example of an HTTP controller that uses the CreateProductUseCase to handle product creation requests:</p><p>public class ProductController : ApiController<br>{<br>&nbsp; &nbsp; private readonly CreateProductUseCase _createProductUseCase;<br><br>&nbsp; &nbsp; public ProductController(CreateProductUseCase createProductUseCase)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; _createProductUseCase = createProductUseCase;<br>&nbsp; &nbsp; }<br><br>&nbsp; &nbsp; [HttpPost]<br>&nbsp; &nbsp; public IActionResult CreateProduct(ProductDto productDto)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; // Map the DTO to a Product entity<br>&nbsp; &nbsp; &nbsp; &nbsp; var product = new Product<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Name = productDto.Name,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Price = productDto.Price<br>&nbsp; &nbsp; &nbsp; &nbsp; };<br><br>&nbsp; &nbsp; &nbsp; &nbsp; // Use the CreateProductUseCase<br>&nbsp; &nbsp; &nbsp; &nbsp; try<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _createProductUseCase.CreateNewProduct(product);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Ok(\"Product created successfully.\");<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; catch (ArgumentException ex)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return BadRequest(ex.Message);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}</p><p style=\"margin-left:0px;\"><strong>3.4. Frameworks and Drivers</strong></p><p style=\"margin-left:0px;\">The outermost layer of Clean Architecture is where you integrate with external frameworks and tools, such as databases, web frameworks, and third-party libraries. This layer contains code that is specific to the chosen technology stack. In C#, this can include database context classes, API controllers, and UI components.</p><h2 style=\"margin-left:0px;\"><strong>3. Benefits of Clean Architecture</strong></h2><p style=\"margin-left:0px;\">Clean Architecture offers several benefits that can greatly impact your software development process and the quality of your codebase:</p><p style=\"margin-left:0px;\"><strong>3.1. Maintainability</strong></p><p style=\"margin-left:0px;\">By enforcing a clear separation of concerns, Clean Architecture makes it easier to maintain and update your codebase. Changes to the user interface, database, or other external components have minimal impact on the core business logic.</p><p style=\"margin-left:0px;\"><strong>3.2. Testability</strong></p><p style=\"margin-left:0px;\">The architectural design of Clean Architecture allows for easy unit testing of the core business logic. You can write unit tests without the need for complex mocking or setup, resulting in a more robust and reliable application.</p><p style=\"margin-left:0px;\"><strong>3.3. Scalability</strong></p><p style=\"margin-left:0px;\">Clean Architecture provides a solid foundation for building scalable applications. The clean separation of concerns and minimal coupling between layers enable your application to grow and adapt to changing requirements without significant refactoring.</p><p style=\"margin-left:0px;\"><strong>3.4. Flexibility</strong></p><p style=\"margin-left:0px;\">The independence from frameworks and technologies allows you to choose the most suitable tools for the job. It also makes it easier to migrate to new technologies or frameworks when needed.</p><h2 style=\"margin-left:0px;\"><strong>Conclusion</strong></h2><p style=\"margin-left:0px;\">Clean Architecture is a powerful and effective approach to designing software that is maintainable, testable, and flexible. By adhering to the core principles of clean separation of concerns and the dependency rule, you can create robust, scalable, and adaptable applications in C# and other programming languages.</p>",
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Title = "Understanding Onion Architecture",
                    Image= "839a00b5-194a-4419-8aa4-a315d5239a92.png",
                    PostUrl = "understanding-onion-architecture",
                    Description = "Understanding Onion Architecture: An Example Folder Structure",
                    Content = "<p style=\"margin-left:0px;\"><strong>Onion Architecture is a software architectural pattern that promotes a modular and loosely coupled design, focusing on separation of concerns and maintainability. It helps developers create applications that are more flexible, testable, and easier to evolve over time. In this article, we will delve into the key concepts of Onion Architecture and provide an example folder structure that illustrates its implementation.</strong></p><h2 style=\"margin-left:0px;\"><strong>Key Concepts of Onion Architecture:</strong></h2><h2 style=\"margin-left:0px;\"><strong>Dependency Rule:</strong></h2><p style=\"margin-left:0px;\">Dependencies flow inward, with inner layers having no knowledge of outer layers. This ensures that high-level modules do not depend on low-level modules directly. Instead, both depend on abstractions, enabling interchangeable implementations and reducing coupling.</p><h2 style=\"margin-left:0px;\"><strong>Layers of the Onion:</strong></h2><ul><li>Domain Layer: Contains the core business logic, entities, and business rules of the application.</li><li>Application Layer: Implements use cases and coordinates the flow of data between the domain and infrastructure layers.</li><li>Infrastructure Layer: Handles external concerns such as databases, file systems, or external services.</li><li>Presentation Layer: Handles user interfaces and presentation-related logic.</li></ul><h2 style=\"margin-left:0px;\"><strong>Separation of Concerns:</strong></h2><p style=\"margin-left:0px;\">Each layer has a distinct responsibility, ensuring that business logic remains decoupled from infrastructure or presentation concerns. This separation improves code maintainability and facilitates testing.</p><h2 style=\"margin-left:0px;\"><strong>Example Folder Structure:</strong></h2><p style=\"margin-left:0px;\">To demonstrate a common folder structure based on Onion Architecture, let’s consider a hypothetical e-commerce application.</p><h2 style=\"margin-left:0px;\"><strong>Domain Layer:</strong></h2><p style=\"margin-left:0px;\">Contains the core business logic and entities.</p><ul><li>Example folders: src/domain/entities, src/domain/repositories, src/domain/services.</li></ul><h2 style=\"margin-left:0px;\"><strong>Application Layer:</strong></h2><ul><li>Implements use cases and orchestrates the interaction between the domain and infrastructure layers.</li><li>Example folders: src/application/usecases, src/application/dtos, src/application/mappers.</li></ul><h2 style=\"margin-left:0px;\"><strong>Infrastructure Layer:</strong></h2><ul><li>Handles external dependencies and technical details.</li><li>Example folders: src/infrastructure/persistence, src/infrastructure/services, src/infrastructure/external.</li></ul><h2 style=\"margin-left:0px;\"><strong>Presentation Layer:</strong></h2><ul><li>Deals with user interfaces and presentation logic.</li><li>Example folders: src/presentation/controllers, src/presentation/views, src/presentation/routes.</li></ul><p style=\"margin-left:0px;\">By organizing the codebase according to this folder structure, developers can easily navigate and modify different components of the application. The folder structure promotes separation of concerns, with dependencies flowing inward, adhering to the dependency rule of Onion Architecture.</p><h2 style=\"margin-left:0px;\"><strong>Benefits of Onion Architecture:</strong></h2><h2 style=\"margin-left:0px;\"><strong>Modularity and Maintainability:</strong></h2><p style=\"margin-left:0px;\">The clear separation of concerns and decoupling of dependencies enable easier maintenance and modification of code, making it more adaptable to changing requirements.</p><h2 style=\"margin-left:0px;\"><strong>Testability:</strong></h2><p style=\"margin-left:0px;\">Each layer can be independently tested, allowing for comprehensive unit tests and ensuring that business logic remains isolated from external dependencies.</p><h2 style=\"margin-left:0px;\"><strong>Flexibility:</strong></h2><p style=\"margin-left:0px;\">The modular design facilitates the introduction of new technologies or frameworks without affecting the core business logic, enhancing the scalability and future-proofing of the application.</p><h2 style=\"margin-left:0px;\"><strong>Conclusion:</strong></h2><p style=\"margin-left:0px;\">Onion Architecture provides a powerful approach to software development, emphasizing modularity, maintainability, and testability. By following the key principles and organizing the codebase into distinct layers, developers can create robust applications that are easier to understand, modify, and extend over time. The example folder structure presented in this article serves as a starting point for implementing Onion Architecture, with the flexibility to adapt it to the specific needs of each project.</p>",
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                }
            };

            IList<Social> socials = new List<Social>()
            {
                new()
                {
                    Icon = "fab fa-linkedin",
                    Url = "https://www.linkedin.com/in/aheroglu/",
                    CreatedAt = DateTime.Now,
                    UpdatedAt = DateTime.Now
                },
                new()
                {
                    Icon = "fab fa-github",
                    Url = "https://github.com/aheroglu",
                    CreatedAt = DateTime.Now,
                    UpdatedAt  =DateTime.Now
                },
            };

            if (!context.Abouts.Any())
            {
                await context.Abouts.AddAsync(about);
            }

            if (!context.Messages.Any())
            {
                await context.Messages.AddRangeAsync(messages);
            }

            if (!context.Posts.Any())
            {
                await context.Posts.AddRangeAsync(posts);
            }

            if (!context.Socials.Any())
            {
                await context.Socials.AddRangeAsync(socials);
            }

            await context.SaveChangesAsync();
        }
    }
}
